package com.um.mt.kyle.lexer;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;

public class Lexer {
    private ArrayList<Token> tokens = new ArrayList<Token>();
    private ArrayList<String> errorLog;
    private boolean done = false;
    int lineNumber = 0;
    //private ArrayList<String> multiplicativeOp = new ArrayList<String>();
    private ArrayList<String> keySymbols = new ArrayList<String>();
    private ArrayList<String> keyWords = new ArrayList<String>();
    private BufferedReader bufferToRead;

    public Lexer(BufferedReader bufferToRead){
        this.bufferToRead = bufferToRead;

        //this.setMultiplicativeOp();
        this.setKeySymbols();
        this.setKeyWords();
    }

    public ArrayList<Token> getTokens() {
        return tokens;
    }

    private void setKeySymbols(){
        keySymbols.add("(");
        keySymbols.add(")");
        keySymbols.add(",");
        keySymbols.add("<-");
        keySymbols.add(";");
        keySymbols.add(":");
        keySymbols.add("{");
        keySymbols.add("}");
        keySymbols.add("'");
        keySymbols.add("\"");
    }

    private void setKeyWords(){
        keyWords.add("not");
        keyWords.add("set");
        keyWords.add("let");
        keyWords.add("if");
        keyWords.add("halt");
        keyWords.add("function");
        keyWords.add("while");
        keyWords.add("read");
        keyWords.add("write");
    }

    /*
    private void setMultiplicativeOp(){
        multiplicativeOp.add("*");
        multiplicativeOp.add("/");
        multiplicativeOp.add("and");
    }
    */

    private static int EOF = -1;


    //-----------------------------Keyword-------------------------------------

    private boolean isKeyword(StringBuffer str){
        boolean out = true;

        if (keyWords.contains(str.toString())){
            tokens.add(new Token(TokenClass.KEYWORD, str.toString(),lineNumber));
        }else {
            out = false;
        }

        return out;
    }


    //-----------------------------KeySymbols-------------------------------------

    private boolean isKeySymbol(StringBuffer str){
        boolean out = true;

        if (keySymbols.contains(str.toString())){
            tokens.add(new Token(TokenClass.KEY_SYMBOL, str.toString(),lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------AdditiveOp-------------------------------------

    private boolean isAdditiveOp(StringBuffer str){
        boolean out = true;

        if (str.toString().matches("^(\\+|or|-)")){
            tokens.add(new Token(TokenClass.ADDITIVE_OP, str.toString(),lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------RelationalOp-------------------------------------

    private boolean isRelationalOp(StringBuffer str){
        boolean out = true;

        if (str.toString().matches("^(<|>|==|!=|<=|>=)")){
            tokens.add(new Token(TokenClass.RELATIONAL_OP, str.toString(),lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------MultiplicativeOp-------------------------------------

    private boolean isMultiplicativeOp(StringBuffer str){
        boolean out = true;

        if (str.toString().matches("^(\\*|and|/)")){
            tokens.add(new Token(TokenClass.MULTIPLICATIVE_OP, str.toString(),lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------Identifier-------------------------------------

    private boolean isIdentifier(StringBuffer str){
        boolean out = true;

        if (str.toString().matches("^[_A-Za-z][_A-Za-z0-9]*")){
            tokens.add(new Token(TokenClass.IDENTIFIER, str.toString(),lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------Literal-------------------------------------

    private boolean isLiteral(int tokenIndex){
        Token token = tokens.get(tokenIndex);

        boolean isLiteral = token.getClazz() == TokenClass.CHAR_LITERAL || token.getClazz() == TokenClass.INTEGER_LITERAL;
        isLiteral = isLiteral || token.getClazz() == TokenClass.REAL_LITERAL || token.getClazz() == TokenClass.STRING_LITERAL;
        isLiteral = isLiteral || token.getClazz() == TokenClass.BOOLEAN_LITERAL || token.getClazz() == TokenClass.UNIT_LITERAL;

        if (isLiteral){
            tokens.remove(tokenIndex);
            tokens.add(tokenIndex,new Token(TokenClass.LITERAL,token,token.getLineNumber()));
        }

        return isLiteral;
    }

    //-----------------------------Type-------------------------------------

    private boolean isType(StringBuffer str){
        boolean out = true;

        if (str.toString().equals("int")){
            tokens.add(new Token(TokenClass.TYPE, str.toString(),lineNumber));
        }else if (str.toString().equals("bool")){
            tokens.add(new Token(TokenClass.TYPE,str.toString(),lineNumber));
        }else if (str.toString().equals("char")){
            tokens.add(new Token(TokenClass.TYPE,str.toString(),lineNumber));
        }else if (str.toString().equals("real")){
            tokens.add(new Token(TokenClass.TYPE,str.toString(),lineNumber));
        }else if (str.toString().equals("string")){
            tokens.add(new Token(TokenClass.TYPE,str.toString(),lineNumber));
        }else if (str.toString().equals("unit")){
            tokens.add(new Token(TokenClass.TYPE, str.toString(),lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------BooleanLiteral-------------------------------------

    private boolean isBooleanLiteral(StringBuffer str){
        boolean out = true;

        if (str.toString().equals("true")){
            tokens.add(new Token(TokenClass.BOOLEAN_LITERAL,true,lineNumber));
        }else if (str.toString().equals("false")){
            tokens.add(new Token(TokenClass.BOOLEAN_LITERAL,false,lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------IntegerLiteral-------------------------------------

    private boolean isIntegerLiteral(StringBuffer str){
        boolean out = true;

        if (str.toString().matches("^[0-9]+$")){
            tokens.add(new Token(TokenClass.INTEGER_LITERAL, Integer.parseInt(str.toString()),lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------RealLiteral-------------------------------------

    private boolean isRealLiteral(StringBuffer str){
        boolean out = true;

        if (str.toString().matches("^[-+]?[0-9]+\\.[0-9]+([eE][-+]?[0-9]+)?$")){
            tokens.add(new Token(TokenClass.REAL_LITERAL, Double.parseDouble(str.toString()),lineNumber));
        }else {
            out = false;
        }

        return out;
    }

    //-----------------------------CharLiteral-------------------------------------

    private boolean isCharLiteral(int tokenIndex){
        boolean out = false;

        if (tokens.size() > tokenIndex + 2){
            boolean openQuotes = tokens.get(tokenIndex).getClazz() == TokenClass.KEY_SYMBOL && tokens.get(tokenIndex).getLexeme().toString().equals("'");
            boolean closeQuotes = tokens.get(tokenIndex+2).getClazz() == TokenClass.KEY_SYMBOL && tokens.get(tokenIndex).getLexeme().toString().equals("'");
            String c = tokens.get(tokenIndex + 1).getLexeme().toString();
            int lineNumber = tokens.get(tokenIndex).getLineNumber();

            if (lineNumber != tokens.get(tokenIndex+2).getLineNumber()){
                return  false;
            }

            boolean isPrintable = c.matches("[\\x20-\\x7E]");

            if (openQuotes && closeQuotes && isPrintable){
                tokens.remove(tokenIndex + 2);
                tokens.remove(tokenIndex + 1);
                tokens.remove(tokenIndex);

                tokens.add(tokenIndex,new Token(TokenClass.CHAR_LITERAL,"'" + c + "'",lineNumber));
            }

            return true;
        }

        return out;
    }

    //-----------------------------StringLiteral-------------------------------------

    private boolean isStringLiteral(int tokenIndex){
        boolean out = false;

        if (tokens.size() > tokenIndex ){
            return false;
        }

        boolean openQuotes = tokens.get(tokenIndex).getClazz() == TokenClass.KEY_SYMBOL && tokens.get(tokenIndex).getLexeme().toString().equals("\"");
        String str = "";
        int lineNumber =tokens.get(tokenIndex).getLineNumber();

        if (openQuotes) {
            for (int loops = tokenIndex + 1; loops < tokens.size() && tokens.get(tokenIndex + loops).getLineNumber() == lineNumber; loops++) {
                if (tokens.get(tokenIndex + loops).getClazz() == TokenClass.KEY_SYMBOL && tokens.get(tokenIndex).getLexeme().toString().equals("\"")) {
                    if (str.length() != 0) {
                        for (int loops2 = loops; loops2 >= tokenIndex; loops2--) {
                            tokens.remove(loops2);
                        }
                        tokens.add(tokenIndex, new Token(TokenClass.STRING_LITERAL, "\"" + str + "\"", lineNumber));
                        return true;
                    } else {
                        return false;
                    }
                } else if (tokens.get(tokenIndex + loops).getLexeme().toString().matches("[\\x20-\\x7E]+")) {
                    str += tokens.get(tokenIndex + loops).getLexeme().toString();
                }
                else {
                    return false;
                }
            }
        }

        return out;
    }

    //-----------------------------UnitLiteral-------------------------------------

    private boolean isUnitLiteral(StringBuffer str){
        boolean out = true;

        if (str.toString().equals("#")){
            tokens.add(new Token(TokenClass.UNIT_LITERAL,str.toString(),lineNumber));
        }else {
            out = false;
        }

        return out;
    }



    public ArrayList<Token> lexIt() throws IOException{
        tokens = new ArrayList<Token>();
        errorLog =  new ArrayList<String>();
        done = false;
        lineNumber = 1;

        System.out.println("Starting lexer");

        getWord();

        tokenShrink();

        System.out.println("Lexer Done");

        return tokens;
    }

    private boolean process(String strIn){
        StringBuffer str = new StringBuffer(strIn);

        boolean out = isType(str) || isBooleanLiteral(str) || isIntegerLiteral(str);
        out = out || isRealLiteral(str);
        out = out || isUnitLiteral(str) || isMultiplicativeOp(str) || isRelationalOp(str);
        out = out || isAdditiveOp(str) || isKeySymbol(str) || isKeyword(str);
        out = out || isIdentifier(str);
        return out;
    }

    private void tokenShrink(){
        for (int loops = 0 ; loops < tokens.size(); loops++) {
            isLiteral(loops);
            isCharLiteral(loops);
            isStringLiteral(loops);
        }
    }

    private void generateErrors(){
        for (int loops = 0 ; loops < tokens.size(); loops++) {
            //int lineNumber = tokens.get(loops);
        }
    }

    private void getWord() throws IOException{
        //if (done) return "";

        boolean openQuotes = false;
        char quote = '\'';
        int lastOpenQuotes = 0;

        StringBuilder out = new StringBuilder();

        int c = (char)bufferToRead.read();

        while (c != EOF && isWhiteSpace((char)c)){
            c = (char)bufferToRead.read();
        }

        while (c != EOF){

            if ((!openQuotes && c == '\'' || c == '"') || (openQuotes && c == quote)){
                quote = (char)c;
                if (out.length() == 0 || out.toString().charAt(out.toString().length()-1) != '\\') {
                    openQuotes = !openQuotes;
                    lastOpenQuotes = lineNumber;
                }
            }

            if ( (isWhiteSpace((char)c) && !openQuotes) || (openQuotes && isNewLine((char)c))) {
                //System.out.println("Read: " + out.toString());
                //return  out.toString();
                openQuotes = false;
                if (!process(out.toString())) {
                    tokens.add(new Token(TokenClass.ERROR, quote, lineNumber-1));
                }

                out.setLength(0);

                do{
                    c = (char)bufferToRead.read();
                }while (c != EOF && isWhiteSpace((char)c));
            }

            if (!isNewLine((char)c)) {
                out.append((char)c);
            }

            tokenize(out);

            c = bufferToRead.read();
        }

        if (!process(out.toString())){
            tokens.add(new Token(TokenClass.ERROR, out.toString(), lineNumber));
        }

        if (openQuotes){
            errorLog.add("Missing '" + quote +  "' at line " + lastOpenQuotes);
        }

        dumpErrors();
    }

    private boolean tokenize(StringBuilder out){
        if (!process(out.toString())){
            if (out.length() == 1 ){
                tokens.add(new Token(TokenClass.ERROR, out.toString(), lineNumber));
                out.setLength(0);
            }else {
                String str = out.toString();
                process(str.substring(0, str.length()-1));
                out.setLength(0);
                out.append(str.charAt(str.length()-1));
                tokenize(out);
            }
            return true;
        }else {
            tokens.remove(tokens.size() - 1);
            return false;
        }
    }

    private boolean isNewLine(char c){
        return (c == '\n');
    }

    private boolean isWhiteSpace(char c){
        if (isNewLine(c)) lineNumber ++;
        return Character.isWhitespace(c);
    }

    private boolean isLetter(char c){
        return Character.isLetter(c);
    }

    private boolean isDigit(char c){
        return Character.isDigit(c);
    }

    private boolean isPrintable(char c){
        return (c >= 0x20 && c <= 0x7E);
    }


    public void displayTokens(ArrayList<Token> tokens){
        for (int loops = 0 ; loops < tokens.size(); loops ++){
            System.out.println(tokens.get(loops).toString());
        }
    }

    private void dumpErrors(){
        if (errorLog.size() > 0){
            System.out.println("Error log:");
        }
        for (int loops = 0 ; loops < errorLog.size(); loops ++){
            System.out.println(errorLog.get(loops));
        }
    }
}
